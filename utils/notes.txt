Na, eddig megcsináltam a frontendet 90%ra full vanilla mindennel. Még készül a generált eventpagek templétje, meg az adminpage nem szép.
Csináltam egy mappát, tele almappákkal.
A rootban git init, weben csináltam egy repót, majd oda pussoltam.
Aztán (lehet picit későn) npm init a rootban, most kezdem a backendet írni és nodejs, expresst fogok használni. A node versiont belőttem nvm-mel LTS-re és most összeszedem a techstacket amit chatgpt adott :)

MongoDB lesz a kis adatbázis, mert tulajdonképpen semmit nem csinálok vele, csak könyvjelzőként funkcionál.
Nodejs és express a szerver ezeket npm installal húzd be.
Multer to handle file uploads, and Mongoose to define the Exhibition model and connect to the database.

Szóval az itteni dockerfile egyelőre csak a nodejs szervernek meg az összes asszetnek az otthonát csinálja meg. de van valahol egy dockerizált mongodb is, az is múködik már a  guiból, de össze lehet valahogy őket kötni valami más fileban, nézd meg a fireship videóját, és akkor egy gombnyomásra egy többszerveren futó webstack elindul débéstől filerendszerestül szerverestül és expózol valami entripontot és tök jó lenne akár ha az adminműveletek tök külön szerveren futnának aminek külön apikulcsa van és pár külön belső fájlja amik nem a közös kifelé facing filerendszerben (volumében) van.

szóval:
valamelyik oldalra ami kiállításokpage mondjuk rakj egy dblehívós szkriptet és paginációval kérj ki 12/9 eventet meg a mappaelérésüket és azokkal töldtsd föl a plugtemplétet amit static htmlként egyben szervelsz a kliensnek.

mongosh "mongodb://localhost:27017" 
#ez a dbszerveren belül cli cliensként emulál egy api terminált

#ez nemtom mit csinál
mongo --host <DOCKER_CONTAINER_IP_ADDRESS> --port <MONGODB_PORT>

ezzel a DBcliben használod adottnevű databázist (eventDB)
#use <DATABASE_NAME>

db.createCollection('<COLLECTION_NAME>', {
  validator: {
    $jsonSchema: {
      bsonType: 'object',
      required: ['id', 'title', 'artist', 'date', 'tags', 'directory', 'numImages', 'isEvent'],
      properties: {
        id: { bsonType: 'number' },
        title: { bsonType: 'string' },
        artist: { bsonType: 'string' },
        date: { bsonType: 'date' },
        tags: { bsonType: 'array', items: { bsonType: 'string' } },
        directory: { bsonType: 'string' },
        numImages: { bsonType: 'number' },
        isEvent: { bsonType: 'bool' }
      }
    }
  }
})

//generate fake entries:

const entries = [
  {
    id: 1,
    title: 'Concert at the park',
    artist: 'The Music Band',
    date: new Date(2023, 3, 15, 19, 30),
    tags: ['music', 'outdoors', 'fun'],
    directory: '/home/user/images/concert',
    numImages: 10,
    isEvent: true
  },
  {
    id: 2,
    title: 'Art exhibition',
    artist: 'Jane Doe',
    date: new Date(2023, 4, 2, 14, 0),
    tags: ['art', 'painting', 'gallery'],
    directory: '/home/user/images/art',
    numImages: 20,
    isEvent: true
  },
  {
    id: 3,
    title: 'Movie night',
    artist: 'Movie Studio',
    date: new Date(2023, 4, 10, 20, 0),
    tags: ['movies', 'popcorn', 'friends'],
    directory: '/home/user/images/movies',
    numImages: 5,
    isEvent: true
  }
];

db.eventsDB.insertMany(entries);


//print all:
const entries = db.eventsDB.find().toArray();
printjson(entries);

//szóval a Dockerfile alapján csinál egy docker imaget a docker build -t imagename filehely (ez lehet csak egy pont is)
//aztán docker login, beállítom a tagot
// docker tag local-image-name exampleuser/repo-name:1.0
// docker push fenykep/repo-name:1.0

//ezt a dockerimaget tudod cliből futtatni, de guiból is
//ha fellőtted dockerhubra, akkor elvileg linoderól is eléred az imaget és az alapján tudsz indítani egy felhőben lakó instanceot

// docker run -p 3000:3000 haromhetdockimg
// itt a -p flag forwardolja a container 3000-res portját a hoszt 3000-ére

//szóval létrehoztam egy alap ubuntu alapú docker linode-ot, abba belessh-ztam, majd lehívom a dockerhubról az odatöltött imagemet

//itt most a /db directory van fókuszban, van saját Dockerfileja, mongod.conf abba még kéne valami log módot rakni meg a db "fizikai" helyét meghatározni, akár valami perzisztens helyen --csekk dockercompose
//és most a docker compose up --build
//elidnítja mindkét containert a db és az app.js es imagekből


I have to make a decision on displaying the menus for the events and exhibitions. Initially I wanted to simply do a db query[bias=page*9 maxrecord=9] and then generate the menu with a pug template, but I realized that now I would only need the whole webserver for this functionality.
30mins later I realized that this is not the case, so Ill stick with two separate nodejs servers for now.

csináltam a databasebe két usert

// db.createUser({
//   user: "client",
//   pwd: "",
//   roles: [{ role: "read", db: "galeriDB" }]
// })

// db.createUser({
//   user: "admin",
//   pwd: "",
//   roles: [{ role: "readWrite", db: "galeriDB" }]
// })

ugye a jelszavakat majd írd át, de ha esetleg ők nem jönnének maguktól létre  akkor egy mongosh shellel ezekkel a kommandokkal hozod őket létre és tudsz majd rájuk csatlakozni